    int fname = strcmp(RecordGetFamilyName(r1), RecordGetFamilyName(r2));
    int gname = strcmp(RecordGetGivenName(r1), RecordGetGivenName(r2));
    if (fname != 0) {
        return fname;
    } else if (gname != 0) {
        return gname;
    } 
    //Case for when name is the same 
    return compareByZid(r1, r2); 
    
    //dbnew
    db->byName = TreeNew(compareByName);
    
    //TreeSearchBetween
    struct list *new = ListNew();
    doTreeSearchBetween(t, t->root, lower, upper, new);
    return new; 
    
    //doTreeSearchBetween
      //Base case 
    if (n == NULL) {
        return;
    }  
    int Rlow = t->compare(lower, n->rec);
    int Rup = t->compare(upper, n->rec);

    if (Rlow < 0) {
        //Recursive call of left subtree
        doTreeSearchBetween(t, n->left, lower, upper, l); 
    } 
    if (Rlow <= 0 && Rup >= 0) {
        //If current value is in the range append to list
        ListAppend(l, n->rec); 
    } 
    if (Rup > 0) {
        //Recursive call of right subtree
        doTreeSearchBetween(t, n->right, lower, upper, l);
    }  
    
    
    
Possible concrete 2-3-4 tree data structure:
typedef struct node {
   int          order;     // 2, 3 or 4
   int          data[3];   // items in node
   struct node *child[4];  // links to subtrees
} node;
    
 //Searching in 2-3-4 Trees
    Search(tree,item):
|  Input  tree, item
|  Output address of item if found in 2-3-4 tree
|         NULL otherwise
|
|  if tree is empty then
|     return NULL
|  else
|  |  scan tree.data to find i such that
|  |     tree.data[i-1] < item ≤ tree.data[i]
|  |  if item=tree.data[i] then   // item found
|  |     return address of tree.data[i]
|  |  else       // keep looking in relevant subtree
|  |     return Search(tree.child[i],item)
|  |  end if
|  end if
    
//Insertion algorithm:
insert(tree,item):
|  Input  2-3-4 tree, item
|  Output tree with item inserted
|
|  if tree is empty then
|     return new node containing item
|  end if
|  node=Search(tree,item)
|  parent=parent of node
|  if node.order < 4 then
|     insert item into node
|     increment node.order
|  else
|  |  promote = node.data[1]     // middle value
|  |  nodeL   = new node containing data[0]
|  |  nodeR   = new node containing data[2]
|  |  delete node
|  |  if item < promote then
|  |     insert(nodeL,item)
|  |  else
|  |     insert(nodeR,item)
|  |  end if
|  |  insert(parent,promote)
|  |  while parent.order=4 do
|  |     continue promote/split upwards
|  |  end while
|  |  if parent is root ∧ parent.order=4 then
|  |     split root, making new root
|  |  end if
|  end if
    
